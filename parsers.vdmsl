module Parsers
imports
    from Util functions unionAll; maxSet
exports all
definitions

types
    Terminal = <Plus> | <Minus> | <Mult> | <Div> | <LParen> | <RParen> | <Digit>;
    Nonterminal = <Number> | <Sum> | <Product> | <Factor>;
    Symbol = Terminal | Nonterminal;

    Rule :: lhs: Nonterminal
            rhs: seq of Symbol;

    Item :: rule: Rule
            progress: nat
        inv item == item.progress <= len item.rule.rhs;

    State = set of Item;

functions
    -- Finds the set of all nonterminals that can reduce to the empty string
    findNullables: set of Rule -> set of Nonterminal
    findNullables(rules) == let
        find: set of Nonterminal -> set of Nonterminal
        find(nullables) == let
            nullables' = {r.lhs | r in set rules &
                forall s in seq r.rhs & s in set nullables
            }
        in
            if nullables = nullables' then nullables
            else find(nullables')
    in find({});

    -- Maps a sequence of symbols to its longest nullable prefix
    -- (a nullable prefix is a prefix in which all symbols are nullable)
    nullPrefix: set of Nonterminal -> seq of Symbol -> seq of Nonterminal
    nullPrefix(nullables)(s) == let
        lastInds = {i | i in set inds s &
            forall x in seq s(1,...,i) & x in set nullables
        }
    in
        if lastInds = {} then []
        else s(1,...,Util`maxSet(lastInds));

    -- Finds all suffixes of s that follow some instance of n
    followSuffixes: Nonterminal -> seq of Symbol -> set of seq of Symbol
    followSuffixes(n)(s) == {s(i+1,...,len s) | i in set inds s & i < len s and s(i) = n}
    post forall fs in set RESULT & len fs > 0;

    -- Maps each nonterminal to the set of its possible start terminals
    findStarts: set of Rule -> set of Nonterminal -> map Symbol to set of Terminal
    findStarts(rules)(nullables) == let
        unionAll = Util`unionAll[Terminal],
        nonterminals = { r.lhs | r in set rules },
        -- The only possible start terminal for a terminal is itself
        -- (terminals are never the lhs of any grammar rule)
        termStarts = { s |-> {s} | s : Terminal },

        find: map Symbol to set of Terminal -> map Symbol to set of Terminal
        find(starts) == let
            -- For each nonterminal n, gather any terminal that could possibly be the first
            -- token of a string matching n. There are two possible ways a terminal t could start
            -- such a string:
            --    1. t is in the start set of some symbol in the nullable prefix of one of n's rules.
            --    2. t is in the start set of the symbol s that directly follows the nullable prefix of
            --       one of n's rules (if there is such a symbol)
            --           - If the nullable prefix is the empty sequence, then s would be the first
            --             symbol of the rule's rhs.
            starts' = termStarts ++ {n |->
                unionAll({let
                    prefix = nullPrefix(nullables)(r.rhs)
                in
                    unionAll({starts(i) | i in seq prefix}) union
                    (if len r.rhs > len prefix then starts(r.rhs(len prefix+1))
                     else {})
                | r in set rules & r.lhs = n})
            | n in set nonterminals}
        in
            if starts' = starts then starts
            else find(starts')
    in find(termStarts ++ {s |-> {} | s in set nonterminals});

    -- Maps each nonterminal to the set of terminals that can directly follow a string matching
    -- one of the nonterminal's rules
    findFollows: set of Rule -> set of Nonterminal -> map Symbol to set of Terminal -> map Nonterminal to set of Terminal
    findFollows(rules)(nullables)(starts) == let
        unionAll = Util`unionAll[Terminal],
        nonterminals = { r.lhs | r in set rules }

        -- For each nonterminal n, search each rule's rhs for occurrences of n and gather any
        -- terminals that could possibly follow n. There are two possible ways a terminal t
        -- could follow n:
        --   1. t is in the start set of some symbol in n's nullable suffix.
        --          - We use the nullable prefix of the follow suffix of n instead of the
        --            nullable suffix, but these are equivalent.
        --   2. t is in the start set of the symbol s that directly follows n's nullable suffix
        --      (if there is such a symbol).
        --          - If n's nullable suffix is the empty sequence, then s is the symbol that
        --            directly follows n.
    in {n |-> unionAll({
            unionAll({let
                nullSuffix = nullPrefix(nullables)(fs)
            in
                unionAll({starts(i) | i in seq nullSuffix}) union
                (if len fs > len nullSuffix then starts(fs(len nullSuffix+1))
                 else {})
            | fs in set followSuffixes(n)(r.rhs)})
        | r in set rules})
    | n in set nonterminals};

    -- Returns the symbol following the dot if the item is incomplete.
    -- Otherwise, returns a sentinel value
    nextSym: Item -> [Symbol]
    nextSym(item) ==
        if item.progress < len item.rule.rhs then
            item.rule.rhs(item.progress+1)
        else nil;

    -- Move the dot forward one
    advanceItem: Item -> Item
    advanceItem(item) == mk_Item(item.rule, item.progress+1)
    pre item.progress < len item.rule.rhs;

    closure: set of Rule -> State -> State
    closure(rules)(s0) == let
        unionAll = Util`unionAll[Item],

        find: State -> State
        find(s) == let
            s' = s union unionAll({
                {mk_Item(r, 0) | r in set rules & r.lhs = nextSym(i)}
            | i in set s})
        in
            if s = s' then s
            else find(s')
    in find(s0);

    goto: set of Rule -> State -> Symbol -> State
    goto(rules)(s)(sym) == closure(rules)({advanceItem(i) | i in set s & nextSym(i) = sym});

end Parsers
